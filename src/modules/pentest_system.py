#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
JARVIS Advanced Network Penetration Testing
Sistema Ã©tico de teste de penetraÃ§Ã£o e anÃ¡lise de rede
"""

import socket
import threading
import subprocess
import json
import time
import os
import hashlib
import base64
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import sqlite3

class NetworkPenetrationTester:
    """Sistema Ã©tico de teste de penetraÃ§Ã£o"""
    
    def __init__(self):
        self.scan_results = {}
        self.vulnerabilities = []
        self.access_methods = {}
        self.db_path = "data/pentest_results.sqlite"
        self.init_database()
        
        # Banner de uso Ã©tico
        print("""
        â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
        â•‘                    âš ï¸  AVISO IMPORTANTE âš ï¸                    â•‘
        â•‘                                                              â•‘
        â•‘  Este sistema Ã© para TESTES Ã‰TICOS E EDUCACIONAIS apenas    â•‘
        â•‘  Use apenas em redes que vocÃª possui ou tem autorizaÃ§Ã£o     â•‘
        â•‘  O uso nÃ£o autorizado pode violar leis locais               â•‘
        â•‘                                                              â•‘
        â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        """)
    
    def init_database(self):
        """Inicializar banco de dados"""
        os.makedirs("data", exist_ok=True)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS pentest_targets (
                target_ip TEXT PRIMARY KEY,
                hostname TEXT,
                os_type TEXT,
                open_ports TEXT,
                services TEXT,
                vulnerabilities TEXT,
                access_methods TEXT,
                risk_level TEXT,
                last_scan TIMESTAMP
            )
        ''')
        
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS exploitation_attempts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_ip TEXT,
                exploit_type TEXT,
                success BOOLEAN,
                payload TEXT,
                response TEXT,
                timestamp TIMESTAMP
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def comprehensive_scan(self, target_network):
        """Varredura abrangente da rede"""
        print(f"ğŸ” Iniciando varredura abrangente: {target_network}")
        
        network_base = target_network.split('/')[0].rsplit('.', 1)[0]
        active_targets = []
        
        # Fase 1: Descoberta de hosts
        print("ğŸ“¡ Fase 1: Descoberta de hosts ativos...")
        active_ips = self.discover_hosts(network_base)
        
        # Fase 2: AnÃ¡lise detalhada por host
        print("ğŸ” Fase 2: AnÃ¡lise detalhada de cada host...")
        for ip in active_ips:
            target_info = self.analyze_target(ip)
            if target_info:
                active_targets.append(target_info)
                self.save_target_info(target_info)
        
        # Fase 3: Testes de penetraÃ§Ã£o
        print("ğŸ¯ Fase 3: Testes de penetraÃ§Ã£o Ã©ticos...")
        for target in active_targets:
            self.ethical_penetration_test(target)
        
        return active_targets
    
    def discover_hosts(self, network_base):
        """Descobrir hosts ativos na rede"""
        active_hosts = []
        
        def ping_host(ip):
            try:
                result = subprocess.run(
                    ['ping', '-n', '1', '-w', '1000', ip],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return ip
            except:
                pass
            return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            ips = [f"{network_base}.{i}" for i in range(1, 255)]
            results = list(executor.map(ping_host, ips))
            active_hosts = [ip for ip in results if ip is not None]
        
        print(f"âœ… {len(active_hosts)} hosts ativos encontrados")
        return active_hosts
    
    def analyze_target(self, target_ip):
        """AnÃ¡lise detalhada do alvo"""
        print(f"ğŸ¯ Analisando: {target_ip}")
        
        target_info = {
            'ip': target_ip,
            'hostname': self.get_hostname(target_ip),
            'os_type': 'unknown',
            'open_ports': [],
            'services': {},
            'vulnerabilities': [],
            'risk_level': 'LOW',
            'access_methods': []
        }
        
        # Scanner de portas abrangente
        target_info['open_ports'] = self.comprehensive_port_scan(target_ip)
        
        # AnÃ¡lise de serviÃ§os
        if target_info['open_ports']:
            target_info['services'] = self.analyze_services(target_ip, target_info['open_ports'])
            target_info['os_type'] = self.detect_os(target_ip, target_info['services'])
            target_info['vulnerabilities'] = self.vulnerability_assessment(target_ip, target_info['services'])
            target_info['access_methods'] = self.identify_access_methods(target_info)
            target_info['risk_level'] = self.calculate_risk_level(target_info)
        
        return target_info
    
    def comprehensive_port_scan(self, target_ip):
        """Scanner de portas abrangente"""
        # Portas mais comuns + serviÃ§os especÃ­ficos
        common_ports = list(range(20, 26)) + list(range(53, 54)) + \
                      list(range(80, 81)) + list(range(110, 111)) + \
                      list(range(135, 140)) + list(range(143, 144)) + \
                      list(range(443, 444)) + list(range(993, 996)) + \
                      [1433, 1521, 3306, 3389, 5432, 5900, 8080, 8443]
        
        open_ports = []
        
        def scan_port(port):
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((target_ip, port))
                sock.close()
                if result == 0:
                    return port
            except:
                pass
            return None
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            results = list(executor.map(scan_port, common_ports))
            open_ports = [port for port in results if port is not None]
        
        return open_ports
    
    def analyze_services(self, target_ip, open_ports):
        """AnÃ¡lise detalhada de serviÃ§os"""
        services = {}
        
        service_map = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 135: 'RPC',
            139: 'NetBIOS', 143: 'IMAP', 443: 'HTTPS', 445: 'SMB',
            993: 'IMAPS', 995: 'POP3S', 1433: 'MSSQL', 1521: 'Oracle',
            3306: 'MySQL', 3389: 'RDP', 5432: 'PostgreSQL',
            5900: 'VNC', 8080: 'HTTP-Alt', 8443: 'HTTPS-Alt'
        }
        
        for port in open_ports:
            service_name = service_map.get(port, 'Unknown')
            
            # Banner grabbing
            banner = self.grab_banner(target_ip, port)
            
            # AnÃ¡lise especÃ­fica por serviÃ§o
            service_info = {
                'name': service_name,
                'banner': banner,
                'version': self.extract_version(banner),
                'security_issues': []
            }
            
            # VerificaÃ§Ãµes de seguranÃ§a especÃ­ficas
            if service_name == 'SSH':
                service_info['security_issues'] = self.check_ssh_security(target_ip, port, banner)
            elif service_name == 'HTTP':
                service_info['security_issues'] = self.check_http_security(target_ip, port)
            elif service_name == 'FTP':
                service_info['security_issues'] = self.check_ftp_security(target_ip, port, banner)
            
            services[port] = service_info
        
        return services
    
    def grab_banner(self, target_ip, port):
        """Capturar banner do serviÃ§o"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target_ip, port))
            
            # Enviar requisiÃ§Ã£o baseada na porta
            if port == 80:
                sock.send(b"HEAD / HTTP/1.0\\r\\n\\r\\n")
            elif port == 21:
                pass  # FTP envia banner automaticamente
            elif port == 22:
                pass  # SSH envia banner automaticamente
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            return banner.strip()
        except:
            return ""
    
    def check_ssh_security(self, target_ip, port, banner):
        """Verificar seguranÃ§a do SSH"""
        issues = []
        
        # Verificar versÃ£o vulnerÃ¡vel
        if 'OpenSSH_7.4' in banner:
            issues.append('VersÃ£o SSH vulnerÃ¡vel (CVE-2018-15473)')
        
        # Tentar autenticaÃ§Ã£o fraca
        weak_credentials = self.test_weak_ssh_credentials(target_ip, port)
        if weak_credentials:
            issues.append(f'Credenciais fracas detectadas: {weak_credentials}')
        
        # Verificar configuraÃ§Ãµes
        config_issues = self.check_ssh_config(target_ip, port)
        issues.extend(config_issues)
        
        return issues
    
    def test_weak_ssh_credentials(self, target_ip, port):
        """Testar credenciais SSH fracas (apenas para demonstraÃ§Ã£o)"""
        # Lista de credenciais comuns para teste Ã©tico
        weak_creds = [
            ('admin', 'admin'), ('admin', 'password'), ('admin', '123456'),
            ('root', 'root'), ('root', 'password'), ('root', 'toor'),
            ('user', 'user'), ('test', 'test'), ('guest', 'guest')
        ]
        
        found_creds = []
        
        # NOTA: Este Ã© apenas um exemplo educacional
        # Em um teste real, usaria bibliotecas como paramiko
        print(f"   ğŸ” Testando credenciais fracas em {target_ip}:{port}")
        
        # Simular teste (nÃ£o executar realmente para seguranÃ§a)
        # Em ambiente real, removeria este return e implementaria o teste
        return None
        
        # CÃ³digo comentado para demonstraÃ§Ã£o
        """
        try:
            import paramiko
            
            for username, password in weak_creds:
                try:
                    ssh = paramiko.SSHClient()
                    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                    ssh.connect(target_ip, port=port, username=username, 
                              password=password, timeout=3)
                    ssh.close()
                    found_creds.append(f'{username}:{password}')
                    break
                except:
                    continue
        except ImportError:
            pass
        """
        
        return found_creds[0] if found_creds else None
    
    def check_http_security(self, target_ip, port):
        """Verificar seguranÃ§a HTTP"""
        issues = []
        
        try:
            import requests
            
            url = f"http://{target_ip}:{port}"
            
            # Verificar headers de seguranÃ§a
            response = requests.get(url, timeout=5)
            headers = response.headers
            
            # Headers de seguranÃ§a ausentes
            security_headers = [
                'X-Frame-Options',
                'X-XSS-Protection',
                'X-Content-Type-Options',
                'Strict-Transport-Security'
            ]
            
            for header in security_headers:
                if header not in headers:
                    issues.append(f'Header de seguranÃ§a ausente: {header}')
            
            # Verificar informaÃ§Ãµes expostas
            if 'Server' in headers:
                issues.append(f'InformaÃ§Ãµes do servidor expostas: {headers["Server"]}')
            
            # Verificar pÃ¡ginas comuns
            common_pages = ['/admin', '/login', '/wp-admin', '/phpmyadmin']
            for page in common_pages:
                try:
                    page_response = requests.get(f"{url}{page}", timeout=3)
                    if page_response.status_code == 200:
                        issues.append(f'PÃ¡gina administrativa exposta: {page}')
                except:
                    pass
            
        except Exception as e:
            pass
        
        return issues
    
    def ethical_penetration_test(self, target_info):
        """Teste Ã©tico de penetraÃ§Ã£o"""
        target_ip = target_info['ip']
        
        print(f"ğŸ¯ Teste de penetraÃ§Ã£o Ã©tico: {target_ip}")
        
        # Testes nÃ£o-invasivos apenas
        penetration_results = {
            'information_gathering': self.information_gathering(target_info),
            'vulnerability_validation': self.validate_vulnerabilities(target_info),
            'security_recommendations': self.generate_recommendations(target_info)
        }
        
        self.save_penetration_results(target_ip, penetration_results)
        
        return penetration_results
    
    def information_gathering(self, target_info):
        """Coleta de informaÃ§Ãµes nÃ£o-invasiva"""
        info = {}
        
        # InformaÃ§Ãµes DNS
        try:
            import socket
            info['hostname'] = socket.gethostbyaddr(target_info['ip'])[0]
        except:
            info['hostname'] = 'Unknown'
        
        # AnÃ¡lise de TTL para OS fingerprinting
        info['os_fingerprint'] = self.analyze_ttl_fingerprint(target_info['ip'])
        
        # InformaÃ§Ãµes de rede
        info['network_info'] = {
            'open_ports_count': len(target_info['open_ports']),
            'services_count': len(target_info['services']),
            'risk_ports': [p for p in target_info['open_ports'] if p in [21, 23, 135, 445]]
        }
        
        return info
    
    def validate_vulnerabilities(self, target_info):
        """Validar vulnerabilidades encontradas"""
        validated = []
        
        for vuln in target_info['vulnerabilities']:
            # ValidaÃ§Ã£o nÃ£o-invasiva
            validation_result = {
                'vulnerability': vuln,
                'confirmed': True,  # Simplificado para este exemplo
                'impact': self.assess_vulnerability_impact(vuln),
                'exploitability': self.assess_exploitability(vuln)
            }
            validated.append(validation_result)
        
        return validated
    
    def generate_recommendations(self, target_info):
        """Gerar recomendaÃ§Ãµes de seguranÃ§a"""
        recommendations = []
        
        # Baseado em portas abertas
        if 23 in target_info['open_ports']:  # Telnet
            recommendations.append({
                'priority': 'HIGH',
                'issue': 'Telnet ativo',
                'recommendation': 'Desativar Telnet e usar SSH',
                'impact': 'Credenciais podem ser interceptadas'
            })
        
        if 21 in target_info['open_ports']:  # FTP
            recommendations.append({
                'priority': 'MEDIUM',
                'issue': 'FTP ativo',
                'recommendation': 'Migrar para SFTP ou FTPS',
                'impact': 'TransferÃªncia de arquivos nÃ£o criptografada'
            })
        
        # Baseado em vulnerabilidades
        for vuln in target_info['vulnerabilities']:
            recommendations.append({
                'priority': 'HIGH',
                'issue': vuln.get('description', 'Vulnerabilidade detectada'),
                'recommendation': 'Aplicar patches de seguranÃ§a',
                'impact': 'Sistema pode ser comprometido'
            })
        
        return recommendations
    
    def save_target_info(self, target_info):
        """Salvar informaÃ§Ãµes do alvo"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO pentest_targets 
            (target_ip, hostname, os_type, open_ports, services, 
             vulnerabilities, risk_level, last_scan)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            target_info['ip'],
            target_info.get('hostname', 'Unknown'),
            target_info.get('os_type', 'Unknown'),
            json.dumps(target_info['open_ports']),
            json.dumps(target_info['services']),
            json.dumps(target_info['vulnerabilities']),
            target_info.get('risk_level', 'LOW'),
            datetime.now().isoformat()
        ))
        
        conn.commit()
        conn.close()
    
    def generate_pentest_report(self):
        """Gerar relatÃ³rio completo de pentest"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('SELECT * FROM pentest_targets')
        targets = cursor.fetchall()
        
        conn.close()
        
        report = {
            'scan_summary': {
                'total_targets': len(targets),
                'high_risk': len([t for t in targets if t[7] == 'HIGH']),
                'medium_risk': len([t for t in targets if t[7] == 'MEDIUM']),
                'low_risk': len([t for t in targets if t[7] == 'LOW'])
            },
            'targets': [],
            'recommendations': self.compile_global_recommendations(targets)
        }
        
        for target in targets:
            target_dict = {
                'ip': target[0],
                'hostname': target[1],
                'os_type': target[2],
                'open_ports': json.loads(target[3]),
                'vulnerabilities': json.loads(target[5]) if target[5] else [],
                'risk_level': target[7]
            }
            report['targets'].append(target_dict)
        
        return report

# Exemplo de uso Ã©tico
if __name__ == "__main__":
    # IMPORTANTE: Use apenas em redes prÃ³prias ou autorizadas
    tester = NetworkPenetrationTester()
    
    print("ğŸ”’ JARVIS Ethical Penetration Testing System")
    print("=" * 50)
    
    # VerificaÃ§Ã£o de autorizaÃ§Ã£o
    network = input("Digite a rede para teste (apenas redes autorizadas): ")
    
    if not network:
        print("âŒ Rede nÃ£o especificada. Saindo...")
        exit()
    
    print(f"\\nğŸ¯ Iniciando teste Ã©tico em: {network}")
    
    # Executar teste
    results = tester.comprehensive_scan(network)
    
    # Gerar relatÃ³rio
    report = tester.generate_pentest_report()
    
    print(f"\\nğŸ“Š RELATÃ“RIO FINAL:")
    print(f"   Alvos testados: {report['scan_summary']['total_targets']}")
    print(f"   Alto risco: {report['scan_summary']['high_risk']}")
    print(f"   MÃ©dio risco: {report['scan_summary']['medium_risk']}")
    print(f"   Baixo risco: {report['scan_summary']['low_risk']}")